---
title: 最短路径
date: 2018-09-11 19:17:17
tags: [图论, 最短路径, 动态规划]
toc: true
reward: true
---

为了数模竞赛再挣扎一下，这几天学习了图论以及相关的最短路径算法，主要有广度优先搜索、Dijkstra 算法、Floyd 算法、Bellman - Ford 算法。

<!--more-->

## 1 - 图论

先说几个概念，有向图，无向图，带权图

### 1.1 - 有向图

先看图：

<center>
    <img src="https://raw.githubusercontent.com/Brycexxx/BlogComments/master/20180909164831.jpg"
         alt='有向图' height=200 />
</center>

如上图，顶点与顶点之间的连线是有方向的，比如 A 与 B ，图中表示只能由 A 到 B，B 到 A 是走不通的。

### 1.2 - 无向图

还是先看图：

<center>
    <img src="https://raw.githubusercontent.com/Brycexxx/BlogComments/master/20180911194112.jpg" 
         alt='无向图' height=200 />
</center>

如上图，顶点与顶点之间的连线是没有方向的，A 可以到 B，B 也可以到 A，其实A 与 B 之间可以有下面的转换：

<center>
    <img src="https://raw.githubusercontent.com/Brycexxx/BlogComments/master/20180911194909.jpg"/>
</center>

也就是说无向图两个顶点实际上构成了环。

### 1.3 - 带权图

嗯，看图吧

<center>
    <img src="https://raw.githubusercontent.com/Brycexxx/BlogComments/master/20180911161539.jpg" 
      alt='有向带权图' height=200 />
</center>

权是权重的意思，就是连线中的数字，当遇到具体问题时，这些权重也就具有了实际意义。比如：A、B 表示两个车站，那么这个权重可表示为 A 与 B 的距离或者表示 A 到 B 需要花费的时间。

实际上这个是有向带权图，那么无向带权图同理，只是少了方向而已。

针对具体问题有时候权重亦可为负，像下面这样：

<center>
    <img src="https://raw.githubusercontent.com/Brycexxx/BlogComments/master/20180911173712.jpg"
         alt='负权边' height=200 />
</center>

针对带负权边的图，相应的最短路径算法也会不一样。

## 2 - 最短路径

这里实现的最短路径算法都是针对有向图

### 2.1 - 广度优先搜索

> 参考资源：《算法图解》

广度优先搜索可以解决无向图的两类问题：

* 从节点 A 出发到 B 存在路径吗
* 从节点 A 出发到 B 的哪条路径最短

**主要思想**：

从起点出发，找到其邻接节点，分别检验，如果是终点，则结束搜索，否则将邻接节点的邻接节点放入队列以便后续检验，如此循环往复直至达到终点。

> 注意：在遍历的过程中，需要记录下已经处理过的节点，否则在遇到环的时候将导致无限循环

算例：

<center>
    <img src="https://raw.githubusercontent.com/Brycexxx/BlogComments/master/20180911194112.jpg" 
         alt='无向图' height=200 />
</center>

python 实现:

```python
def bfs():
    """
    广度优先搜索
    求 A 到 E 的最短路径
    """
    from collections import deque
    # 初始化图
    graph = {}
    graph['A'] = ['C', 'B']
    graph['B'] = ['D', 'E']
    graph['C'] = ['B', 'D']
    graph['D'] = ['E']
    graph['E'] = []

    search_queue = deque()
    search_queue += graph['A']
    # 用于记录处理过的顶点
    searched = []
    track = {'B': 'AB', 'C': 'AC', 'D': '*' * len(list(graph.keys())), 'E': '*' *                   len(list(graph.keys()))}

    while search_queue:
        point = search_queue.popleft()
        if point not in searched:
            for p in graph[point]:
                temp_track = track[point] + p
                if len(track[p]) > len(temp_track):
                    track[p] = temp_track
            if 'E' in graph[point]:
                return track['E']
            else:
                search_queue += graph[point]
                searched.append(point)
    return '无最短路径'
```

结果：ABE

### 2.2 - Dijkstra 算法

> 参考资源：
>
> 1. 《算法图解》
> 2. 博客链接：http://x-wei.github.io/shortest-path-summary.html

dijkstra 算法主要解决的是在无负权边的有向无环图中从选定起点到图中任意节点的最短路径问题

**该算法主要由四个步骤：**

* 找出开销最小的节点

* 遍历该节点的邻居，检查它的邻居如果经过这个节点是否会有更少的开销，如果是就更新邻居的开销，并记录下该节点，以防止再次被遍历
* 重复上述过程，遍历所有节点
* 计算最终路径

<center>
    <img src="https://raw.githubusercontent.com/Brycexxx/BlogComments/master/20180911161539.jpg" 
      alt='有向带权图' height=200 />
</center>

为什么每次要找开销最小的节点呢，举个例子：

如上图，如果首先遍历的是 B 点，那么 D 和 E 的开销将更新为 7 和 11，然后遍历 C，此时 B 的开销被再次更新了，也就是说之前 D 经由 B 的开销更新得到的并不是最短路径，而之后也并不会被更新为 6，D 经过 C 的更新仍为 7，D 可以经过的 B、C 两点都已经被处理，那么 D 也就没有再次被更新的机会，以至得到了错误的结果。

python 实现：

```python
def dijkstra():
    """
    图解算法, 单源最短路径, A -> E
    """
    # 初始化图
    graph = {}
    graph['A'] = {'B': 6, 'C': 3}
    graph['B'] = {'D': 1, 'E': 5}
    graph['C'] = {'B': 2, 'D': 4}
    graph['D'] = {'E': 3}
    graph['E'] = {}
    # 初始化开销
    costs = {'B': 6, 'C': 3, 'D': float('inf'), 'E': float('inf')}
    # 初始化父节点
    parents = {'B': 'A', 'C': 'A', 'D': None, 'E': None}
    # 记录处理过的顶点
    processed= []

    node = find_lowest_cost_node(costs, processed)
    while node:
        neighbors = graph[node]
        for neighbor, cost in neighbors.items():
            new_cost = costs[node] + cost
            if new_cost < costs[neighbor]:
                costs[neighbor] = new_cost
                parents[neighbor] = node
        processed.append(node)
        node = find_lowest_cost_node(costs, processed)

    # 获取最短路径
    n = 'E'
    min_route = ' -> E'
    while True:
        n = parents.get(n)
        if n == 'A':
            min_route = 'A' + min_route
            break
        min_route = ' -> %s' % n + min_route
    
    return costs, min_route

def find_lowest_cost_node(costs, processed):
    lowest_cost = float('inf')
    lowest_cost_node = None
    for node, cost in costs.items():
        if cost < lowest_cost and node not in processed:
            lowest_cost = cost
            lowest_cost_node = node
    return lowest_cost_node
```

计算结果：({'B': 6, 'C': 2, 'D': 7, 'E': 10},  'A -> C -> B -> D -> E')

第一个结果表示起点 A 经过其他所有节点的最短路径结果，第二个结果表示 A 到 E 的最短路径

### 2.3 - Floyd 算法

> 参考资源：
>
> 博客1：http://x-wei.github.io/shortest-path-summary.html
>
> 博客2：https://blog.csdn.net/MyStringIsNotNull/article/details/71505129
>
> [维基百科](https://zh.wikipedia.org/wiki/Floyd-Warshall%E7%AE%97%E6%B3%95)

Floyd 算法主要解决处理有向图或负权（但不可存在负权回路）中任意两个节点的最短路径问题

**算法原理**：

私以为：依次使用每一个节点作为中间节点，来更新任意两个节点间的最短路径

官方版：

<center>
    <img src="https://raw.githubusercontent.com/Brycexxx/BlogComments/master/20180911215318.jpg"/>
</center>

算例：

<center>
    <img src="https://raw.githubusercontent.com/Brycexxx/BlogComments/master/20180911215431.jpg"
         alt='有向带权图' height=200 />
</center>

```python
def floyd():
    """
    任意两点最短路径
    """
    # 给顶点编号
    point2num = {'S': 0, 'A': 1, 'B': 2, 'E': 3}
    # 权重
    w = {(0, 1): 6, (0, 2): 2, (1, 3): 1, (2, 1): 3, (2, 3): 5}
    # 初始化邻接矩阵
    adjacent_matrix = [[float('inf')] * 4, [float('inf')] * 4, [float('inf')] * 4,                            [float('inf')] * 4]
    adjacent_matrix[0][0] = adjacent_matrix[1][1] = adjacent_matrix[2][2] = 								    adjacent_matrix[3][3] = 0
    for e, v in w.items():
        i, j = e
        adjacent_matrix[i][j] = v

    # 可经过的顶点
    for k in range(4):
        # 起点
        for i in range(4):
            # 终点
            for j in range(4):
                adjacent_matrix[i][j] = min(adjacent_matrix[i][j], adjacent_matrix[i]											[k] + adjacent_matrix[k][j])
    return adjacent_matrix
```

计算结果：

| 节点 |  S   |  A   |  B   |  E   |
| :--: | :--: | :--: | :--: | :--: |
|  S   |  0   |  5   |  2   |  6   |
|  A   | inf  |  0   | inf  |  1   |
|  B   | inf  |  3   |  0   |  4   |
|  E   | inf  | inf  | inf  |  0   |

### 2.4 - Bellman-Ford 算法

> 参考资源：
>
> [维基百科](https://zh.wikipedia.org/wiki/%E8%B4%9D%E5%B0%94%E6%9B%BC-%E7%A6%8F%E7%89%B9%E7%AE%97%E6%B3%95)

Bellman-Ford 算法可正确处理带负权边的有向图单源最短路径问题，而 dijkstra 算法很多时候无法正确处理，下面将举例说明

**算法原理：**

对于有 n 个节点的图，图中任意两点间的最短路径线段数不会超过 n - 1，所以进行 n - 1 次循环，每次循环遍历每个节点，用该节点到其邻居的开销更新起点到其邻居的最短路径，这个动作叫做**松弛**；其实可以发现，循环 n - 1 次是最糟糕的情况，每次只更新一条边，所以可以在循环中判定，如果某次循环不存在松弛的情况，就可以提前结束循环

<center>
    <img src="https://raw.githubusercontent.com/Brycexxx/BlogComments/master/20180911173712.jpg"
         alt='负权边' height=200 />
</center>

**官方解释：**

贝尔曼-福特算法与迪科斯彻算法类似，都以松弛操作为基础，即估计的最短路径值渐渐地被更加准确的值替代，直至得到最优解。在两个算法中，计算时每个边之间的估计距离值都比真实值大，并且被新找到路径的最小长度替代。 然而，迪科斯彻算法以贪心法选取未被处理的具有最小权值的节点，然后对其的出边进行松弛操作；而贝尔曼-福特算法简单地对所有边进行松弛操作，共 n - 1次，其中 n 是图的点的数量。在重复地计算中，已计算得到正确的距离的边的数量不断增加，直到所有边都计算得到了正确的路径。这样的策略使得贝尔曼-福特算法比迪科斯彻算法适用于更多种类的输入。

python 实现：

```python
def bellman_ford():
    """
    负权边单源最短路径
    """
    # 初始化图
    graph = {}
    graph['A'] = {'B': 6, 'C': 3}
    graph['B'] = {'C': -4, 'D': 1, 'E': 5}
    graph['C'] = {'D': 4}
    graph['D'] = {'E': 3}
    graph['E'] = {}
    # 初始化 A 到各个顶点的开销
    costs = {'A': 0, 'B': 6, 'C': 3, 'D': float('inf'), 'E': float('inf')}
    # 初始化父节点
    parents = {'B': 'A', 'C': 'A', 'D': None, 'E': None}

    for _ in range(4):
        for parent, neighbors in graph.items():
            for node, cost in neighbors.items():
                new_cost = costs[parent] + cost
                if new_cost < costs[node]:
                    costs[node] = new_cost
                    parents[node] = parent

    # 获取最短路径
    n = 'E'
    min_route = ' -> E'
    while True:
        n = parents.get(n)
        if n == 'A':
            min_route = 'A' + min_route
            break
        min_route = ' -> %s' % n + min_route

    return costs, min_route
```

计算结果：({'A': 0, 'B': 6, 'C': 2, 'D': 6, 'E': 9}, 'A -> B -> C -> D -> E')

如果采用 dijkstra 算法进行计算，得到的结果将是 ({'B': 6, 'C': 2, 'D': 7, 'E': 10}, 'A -> B -> C -> D -> E')，可以看到 D 和 E 并不是最短路径，由于负权边的存在，C 节点在被处理后被再次更新，导致 dijkstra 算法失效，原理上与不选取最便宜节点导致失效是一样的

