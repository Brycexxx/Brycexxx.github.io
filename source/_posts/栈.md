---
title: 栈
date: 2018-11-22 10:48:50
tags: [python, 数据结构, 算法]
toc: true
---

基于 python 的 list 以及上次自己实现的[单链表](https://brycexxx.github.io/2018/11/19/%E5%8D%95%E9%93%BE%E8%A1%A8/)实现了固定容量的栈以及动态扩容栈

<!--more-->

### 1 基于 list 的栈

```python
# 基于 list 实现固定容量的栈
class ListStack:

    def __init__(self, capacity):
        self.val = []
        self.capacity = capacity

    # 入栈
    def push(self, data):
        if len(self.val) >= self.capacity:
            return False
        self.val.append(data)
        return True

    # 出栈
    def pop(self):
        if len(self.val) == 0:
            return None
        return self.val.pop()

    def __len__(self):
        return len(self.val)

    def __repr__(self):
        """
        显示栈的固定容量
        """
        return "<ListStack: %d>" % self.capacity

class DynamicListStack:

    def __init__(self):
        self.val = []

    def push(self, data):
        self.val.append(data)
        return True

    def pop(self):
        if len(self.val) == 0:
            return None
        return self.val.pop()

    def __len__(self):
        return len(self.val)

    def __repr__(self):
        """
        显示栈的当前大小
        """
        return "<DynamicListStack: %d>" % len(self.val)
```

### 2 基于单链表的栈

#### 2.1 调用已经实现的接口

```python
from single_linked_list import SingleLinkedList

class SingleLinkedStack:

    def __init__(self):
        self.items = SingleLinkedList()
        self.length = 0

    def push(self, item):
        self.items.append(item)
        self.length += 1
        return True

    def pop(self):
        if len(self.items) == 0:
            return None
        return self.items.pop(self.length - 1)

    def __len__(self):
        return len(self.items)

    def __repr__(self):
        """
        显示栈的容量
        """
        return "<SingleLinkedStack: %d>" % self.capacity
```

* 可以看出基于 list 和自己实现的单链表代码都比较简单且非常相似，这是因为单链表中已经完成了和 list 类似的加入和弹出的接口，所以直接调用接口实现的代码都是高度相似的

#### 2.2 未调用已实现的接口，从单链表的头部插入

```python
from single_linked_list import Node

# 未调用现成的接口，并从链表的头部插入      
class SingleLinkedStack:

    def __init__(self, head=None):
        self.head = head
        self.length = 0

    def push(self, item):
        new_node = Node(item)
        new_node._next = self.head
        self.head = new_node
        self.length += 1
        return True

    def pop(self):
        if not self.head:
            return None
        pop_value = self.head.val
        self.head = self.head._next
        return pop_value

    def __len__(self):
        return self.length

    def __repr__(self):
        """
        显示栈的大小
        """
        return "<SingleLinkedStack2: %d>" % self.length
```

* 如果从单链表的尾部插入呢

从上面的代码可以看出，单链表头部插入实现的栈，入栈和出栈的时间复杂度都是 O(1)，下面看看尾部插入实现的时间复杂度：

```python
from single_linked_list import Node

# 未调用现成的接口，并从链表的尾部插入  
class SingleLinkedStack:
    def __init__(self, head=None):
        self.head = head
        self.length = 0

    def push(self, item):
        node = self.head
        new_node = Node(item)
        if not node:
            self.head = new_node
            self.length += 1
            return True
        while node:
            prev = node
            node = node._next
        prev._next = new_node
        self.length += 1
        return True

    def pop(self):
        if self.length == 0:
            return None
        node = self.head
        if not node._next:
            self.head = None
            self.length -= 1
            return node.val
        while node:
            prev = node
            node = node._next
            if not node._next:
                break
        prev._next = None
        self.length -= 1
        return node.val

    def __len__(self):
        return self.length

    def __repr__(self):
        """
        显示栈的大小
        """
        return "<SingleLinkedStack1: %d>" % self.length
```

显然尾部插入的实现时间复杂度是 O(n)

