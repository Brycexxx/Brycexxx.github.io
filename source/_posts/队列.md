---
title: 队列
date: 2018-11-23 19:03:56
tags: [python, 数据结构, 算法]
toc: true
---

基于单链表以及 python 的 list 的 4 种不同实现方法的队列，包括普通队列以及循环队列

<!--more-->

### 1 基于单链表实现的队列

```python
from single_linked_list import Node

class SingleLinkedQueue:

    def __init__(self):
        self._head = None
        self._tail = None
        self.length = 0

    def enqueue(self, item):
        new_item = Node(item)
        if not self._head:
            self._head = new_item
        else:
            self._tail._next = new_item
        self._tail = new_item
        self.length += 1
        return True

    def dequeue(self):
        if not self._head:
            return None
        val = self._head.val
        self._head = self._head._next
        self.length -= 1
        return val

    def __len__(self):
        return self.length

    def __repr__(self):
        return "<SingleLinkedQueue: %d>" % self.length
```

### 2 基于 list 且完全通过调用 api 实现

```python
class ListQueue:

    def __init__(self, capacity=10):
        self._items = []
        self.capacity = capacity

    def enqueue(self, item):
        if len(self._items) == self.capacity:
            return False
        self._items.append(item)
        return True

    def dequeue(self):
        if len(self._items) == 0:
            return None
        return self._items.pop(0)

    def __len__(self):
        return len(self._items)

    def __repr__(self):
        return "<ListQueue: [%s]>" % ', '.join(str(item) for item in self._items)
```

### 3 基于 list 通过控制头尾节点实现

```python
class ArrayQueue:

    def __init__(self, capacity=10):
        self._items = []
        self._head = 0
        self._tail = 0
        self.capacity = capacity

    def enqueue(self, item):
        if self._tail == self.capacity:
            if self._head == 0:
                return False
            self._items[0: self._tail - self._head] = self._items[self._head: self._tail]
            self._tail -= self._head
            self._head = 0
        if self.capacity > len(self._items):
            self._items.append(item)
        else:
            self._items[self._tail] = item
        self._tail += 1
        return True

    def dequeue(self):
        if self._head == self._tail:
            return None
        ret = self._items[self._head]
        self._head += 1
        return ret

    def __len__(self):
        return len(self._items)

    def __repr__(self):
        return "<ArrayQueue: [%s]>" % ', '.join(str(item) for item in self._items)
```

### 4 基于 list 通过控制头尾节点实现的循环队列

```python
class CircleArrayQueue:

    def __init__(self, capacity):
        self._items = []
        self._head = 0
        self._tail = 0
        self.capacity = capacity

    def enqueue(self, item):
        if (self._tail + 1) % self.capacity == self._head:
            return False
        if self.capacity > len(self._items):
            self._items.append(item)
        else:
            self._tail %= self.capacity
            self._items[self._tail] = item
        self._tail += 1
        return True

    def dequeue(self):
        if self._head == self._tail:
            return None
        ret = self._items[self._head]
        self._head = (self._head + 1) % self.capacity
        return ret

    def __len__(self):
        return len(self._items)

    def __repr__(self):
        return "<CircleArrayQueue: [%s]>" % ', '.join(str(item) for item in self._items)
```

