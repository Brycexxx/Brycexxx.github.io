---
title: 单链表 & 判断回文串
date: 2018-11-19 17:34:44
tags: [python, 数据结构, 算法]
---

单链表的 python 实现，主要包括了增加、删除、修改、插入，清除等方法；利用构造的单链表存储字符串，并判断是否是回文串。

<!--more-->

### 1 单链表

```python
# 节点类
class Node:
    
    def __init__(self, data, _next=None):
        self.data = data
        self._next = _next
        
    def __repr__(self):
        return "<Node: %d>" % self.data

# 单链表
class SingleLinkedList:

    def __init__(self):
        self.head = None
        self.length = 0

    def is_empty(self):
        return True if not self.length else False

    def append(self, data_or_node):
        if isinstance(data_or_node, Node):
            new_node = data_or_node
        else:
            new_node = Node(data_or_node)

        if not self.head:
            self.head = new_node
        else:
            node = self.head
            while node._next:
                node = node._next
            node._next = new_node
        self.length += 1
        return 

    def update(self, index, data):
        if self.length <= index or index < 0:
            print('out of index')
            return 
        node = self.head
        for _ in range(index):
            node = node._next
        node.data = data
        return 

    def pop(self, index=0):
        if self.length <= index or index < 0:
            print("out of index")
            return None

        if index == 0:
            self.head = self.head._next
        else:
            node = self.head
            for _ in range(index-1):
                node = node._next
            prev = node
            current_node_data = prev._next.data
            after = node._next._next
            prev._next = after
        self.length -= 1
        return current_node_data

    def insert(self, index, data_or_node):
        if isinstance(data_or_node, Node):
            new_node = data_or_node
        else:
            new_node = Node(data_or_node)

        node = self.head
        if index > self.length:
            while node._next:
                node = node._next
            node._next = new_node
        elif index <= 0:
            new_node._next = self.head
            self.head = new_node
        else:
            for _ in range(index-1):
                node = node._next
            prev = node
            current = node._next
            prev._next = new_node
            new_node._next = current
        self.length += 1
        return 

    def clear(self):
        self.head = None
        self.length = 0
        return 

    def get_item(self, index):
        if index >= self.length or index < 0:
            print("out of index")
            return 
        
        node = self.head
        for _ in range(index):
            node = node._next
        
        return node.data

    def get_index(self, data):
        node = self.head
        for i in range(self.length):
            if node.data == data:
                return i
            node = node._next
        return None

    def print_all(self):
        node = self.head
        if not Node:
            print('None')
            return 
        while node._next:
            print(node.data)
            node = node._next
        print(node.data)
        return  

    def __repr__(self):
        return "<SingleLinkedList: %d>" % self.length

    def __len__(self):
        return self.length

    def __getitem__(self, index):
        return self.get_item(index)

    def __setitem__(self, index, data):
        return self.update(index, data)
```

### 2 回文串的判断

* 主要思路
  1. 使用快慢指针寻找中间节点
  2. 对后半部分逆序
  3. 循环对比

```python
from single_linked_list import SingleLinkedList

def is_palindrome(single_linked):
    fast, slow = single_linked.head, single_linked.head
    # 寻找中间节点
    while fast._next and fast._next._next:
        slow = slow._next
        fast = fast._next._next
    # 后半部分逆序
    prev = slow._next
    current = prev._next
    after = prev._next._next
    prev._next = None
    while True:
        current._next = prev
        prev = current
        current = after
        if not current:
            second_part = SingleLinkedList(prev)
            break
        else:
            after = current._next
    # 判断是否是回文串
    node1 = single_linked.head
    node2 = second_part.head
    while node2:
        if node1.data != node2.data:
            return False
        else:
            node1 = node1._next
            node2 = node2._next
    return True
```

