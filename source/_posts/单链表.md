---
title: 单链表
date: 2018-11-19 17:34:44
tags: [python, 数据结构]
---

单链表的 python 实现，主要包括了增加、删除、修改、插入，清除等方法

<!--more-->

```python
# 节点类
class Node:
    
    def __init__(self, data, next_=None):
        self.data = data
        self.next_ = next_
        
    def __repr__(self):
        return "<Node: %d>" % self.data

# 单链表
class SingleLinkedList:

    def __init__(self):
        self.head = None
        self.length = 0

    def is_empty(self):
        return True if not self.length else False

    def append(self, data_or_node):
        if isinstance(data_or_node, Node):
            new_node = data_or_node
        else:
            new_node = Node(data_or_node)

        if not self.head:
            self.head = new_node
        else:
            node = self.head
            while node.next_:
                node = node.next_
            node.next_ = new_node
        self.length += 1
        return 

    def update(self, index, data):
        if self.length <= index or index < 0:
            print('out of index')
            return 
        node = self.head
        for _ in range(index):
            node = node.next_
        node.data = data
        return 

    def pop(self, index=0):
        if self.length <= index or index < 0:
            print("out of index")
            return None

        if index == 0:
            self.head = self.head.next_
        else:
            node = self.head
            for _ in range(index-1):
                node = node.next_
            prev = node
            current_node_data = prev.next_.data
            after = node.next_.next_
            prev.next_ = after
        self.length -= 1
        return current_node_data

    def insert(self, index, data_or_node):
        if isinstance(data_or_node, Node):
            new_node = data_or_node
        else:
            new_node = Node(data_or_node)

        node = self.head
        if index > self.length:
            while node.next_:
                node = node.next_
            node.next_ = new_node
        elif index <= 0:
            new_node.next_ = self.head
            self.head = new_node
        else:
            for _ in range(index-1):
                node = node.next_
            prev = node
            current = node.next_
            prev.next_ = new_node
            new_node.next_ = current
        self.length += 1
        return 

    def clear(self):
        self.head = None
        self.length = 0
        return 

    def get_item(self, index):
        if index >= self.length or index < 0:
            print("out of index")
            return 
        
        node = self.head
        for _ in range(index):
            node = node.next_
        
        return node.data

    def get_index(self, data):
        node = self.head
        for i in range(self.length):
            if node.data == data:
                return i
            node = node.next_
        return None

    def print_all(self):
        node = self.head
        if not None:
            print('None')
            return 
        while node.next_:
            print(node.data)
            node = node.next_
        print(node.data)
        return  

    def __repr__(self):
        return "<SingleLinkedList: %d>" % self.length

    def __len__(self):
        return self.length

    def __getitem__(self, index):
        return self.get_item(index)

    def __setitem__(self, index, data):
        return self.update(index, data)
```

