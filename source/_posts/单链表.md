---
title: 单链表
date: 2018-11-19 17:34:44
tags: [python, 数据结构, 算法]
---

单链表的 python 实现，主要包括了增加、删除、修改、插入，清除等方法；利用构造的单链表存储字符串，并判断是否是回文串；基于单链表的 LRU (least recently used) 缓存淘汰算法

<!--more-->

### 1 单链表

```python
# 节点类
class Node:
    
    def __init__(self, val, _next=None):
        self.val = val
        self._next = _next
        
    def __repr__(self):
        return "<Node: %d>" % self.val

# 单链表
class SingleLinkedList:

    def __init__(self, head=None):
        self.head = head
        self.length = 0

    def is_empty(self):
        return True if not self.length else False

    def append(self, val_or_node):
        if isinstance(val_or_node, Node):
            new_node = val_or_node
        else:
            new_node = Node(val_or_node)

        if not self.head:
            self.head = new_node
        else:
            node = self.head
            while node._next:
                node = node._next
            node._next = new_node
        self.length += 1
        return 

    def update(self, index, val):
        if self.length <= index or index < 0:
            print('out of index')
            return 
        node = self.head
        for _ in range(index):
            node = node._next
        node.val = val
        return 

    def pop(self, index=0):
        if self.length <= index or index < 0:
            print("out of index")
            return None

        if index == 0:
            self.head = self.head._next
        else:
            node = self.head
            for _ in range(index-1):
                node = node._next
            prev = node
            current_node_val = prev._next.val
            after = node._next._next
            prev._next = after
        self.length -= 1
        return current_node_val

    def insert(self, index, val_or_node):
        if isinstance(val_or_node, Node):
            new_node = val_or_node
        else:
            new_node = Node(val_or_node)

        node = self.head
        if index > self.length:
            while node._next:
                node = node._next
            node._next = new_node
        elif index <= 0:
            new_node._next = self.head
            self.head = new_node
        else:
            for _ in range(index-1):
                node = node._next
            prev = node
            current = node._next
            prev._next = new_node
            new_node._next = current
        self.length += 1
        return 

    def clear(self):
        self.head = None
        self.length = 0
        return 

    def get_item(self, index):
        if index >= self.length or index < 0:
            print("out of index")
            return 
        
        node = self.head
        for _ in range(index):
            node = node._next
        
        return node.val

    def get_index(self, val):
        node = self.head
        for i in range(self.length):
            if node.val == val:
                return i
            node = node._next
        return None

    def print_all(self):
        node = self.head
        if not Node:
            print('None')
            return 
        while node._next:
            print(node.val)
            node = node._next
        print(node.val)
        return  

    def __repr__(self):
        return "<SingleLinkedList: %d>" % self.length

    def __len__(self):
        return self.length

    def __getitem__(self, index):
        return self.get_item(index)

    def __setitem__(self, index, val):
        return self.update(index, val)
```

### 2 回文串的判断

* 主要思路：
  1. 使用快慢指针寻找中间节点
  2. 对后半部分逆序
  3. 循环对比
* 完整代码：

```python
from single_linked_list import SingleLinkedList

def is_palindrome1(single_linked):
    # 如果回文串长度为 0 或 1 则为回文串
    if single_linked.length in [0, 1]:
        return True
    fast, slow = single_linked.head, single_linked.head
    # 寻找中间节点
    while fast._next and fast._next._next:
        slow = slow._next
        fast = fast._next._next
    # 后半部分逆序
    prev = slow._next
    if not prev._next:
        second_part = SingleLinkedList(prev)
    else:
        current = prev._next
        after = prev._next._next
        prev._next = None
        while True:
            current._next = prev
            prev = current
            current = after
            if not current:
                second_part = SingleLinkedList(prev)
                break
            else:
                after = current._next
    # 判断是否是回文串
    node1 = single_linked.head
    node2 = second_part.head
    while node2:
        if node1.val != node2.val:
            return False
        else:
            node1 = node1._next
            node2 = node2._next
    return True
```

* 之前没想通的简洁版本

```python
# 简洁版本
def is_palindrome2(single_linked):
    if single_linked.length in [0, 1]:
        return True

    prev = None
    fast = single_linked.head
    slow = single_linked.head

    # 慢指针前进过程中前半部分逆序
    while fast and fast._next:
        fast = fast._next._next
        next_ = slow._next
        slow._next = prev
        prev = slow
        slow = next_

    # 针对奇数情况
    if fast:
        slow = slow._next

    # 对比
    while slow:
        if slow.val != prev.val:
            return False
        else:
            slow = slow._next
            prev = prev._next
    return True
```

### 3 LRU 缓存淘汰算法

* 主要思路
  1. 遍历缓存，如果缓存中已经存在，则删除原来所在的位置，然后插入链表的头部
  2. 如果缓存中不存在：
     1. 如果缓存已满，则先删除链表最后一个节点，然后将此节点插入链表头部
     2. 如果缓存未满。则直接将此节点插入链表头部
* 完整代码：

```python
from single_linked_list import SingleLinkedList, Node

def least_recently_used(data, cache, n=10):
    if data == None:
        return cache

    prev = None
    node = cache.head
    while node:
        if node.val == data:
            if not prev:
                return cache
            prev._next = node._next
            node._next = cache.head
            cache.head = node
            return cache
        # 确保能拿到倒数第二个方便后面缓存满的时候删掉最后一个
        if node._next:
            prev = node
        node = node._next
    # 如果不在缓存中
    # 如果缓存已满，删掉最后一个
    if cache.length == n:
        prev._next = None
        cache.length -= 1
    # 缓存未满
    new_node = Node(data)
    new_node._next = cache.head
    cache.head = new_node
    cache.length += 1
    return cache
```

